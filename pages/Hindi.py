import os
import streamlit as st
import google.generativeai as genai
from dotenv import load_dotenv
from langchain_core.messages import AIMessage, HumanMessage
from deep_translator import GoogleTranslator
from functools import lru_cache
import time
import re
from typing import Optional, List
from utils import initialize_session_state, apply_language_styles, save_user_preferences, get_user_preferences

# Constants
MAX_LINKS = 5
RESPONSE_TIMEOUT = 30
MIN_RESPONSE_LENGTH = 50

class HindiChatBot:
    """Hindi language chatbot with optimized performance and error handling"""
    
    def __init__(self):
        self._model = None
        self._initialize_environment()
    
    def _initialize_environment(self):
        """Initialize environment variables and session state"""
        load_dotenv()
        initialize_session_state()
        apply_language_styles('Hindi')
    
    @lru_cache(maxsize=32)
    def get_translator(self, src: str, dest: str):
        """Get cached translator instance"""
        try:
            return GoogleTranslator(source=src, target=dest)
        except Exception as e:
            st.warning(f"‚ö†Ô∏è Translation service error: {str(e)}")
            return None
    
    @st.cache_resource
    def get_model_config(_self):
        """Get cached model configuration optimized for Hindi"""
        return {
            "temperature": 0.1,
            "top_p": 0.8,
            "top_k": 45,  # Slightly higher for better Hindi vocabulary
            "max_output_tokens": 1500,
            "stop_sequences": ["---‡§∏‡§Æ‡§æ‡§™‡•ç‡§§---"]
        }
    
    @st.cache_resource
    def get_model(_self):
        """Get cached model instance with Hindi-specific configuration"""
        try:
            genai_api_key = os.getenv("GOOGLE_API_KEY")
            if not genai_api_key:
                raise ValueError("‚ùå Google Generative AI ‡§ï‡•á ‡§≤‡§ø‡§è API key ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡•Ä‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§Ö‡§™‡§®‡•Ä environment variables ‡§ú‡§æ‡§Ç‡§ö‡•á‡§Ç‡•§")
            
            genai.configure(api_key=genai_api_key)
            
            system_instruction = """‡§Ü‡§™ ‡§è‡§ï ‡§µ‡§ø‡§∂‡•á‡§∑‡§ú‡•ç‡§û ‡§π‡§ø‡§Ç‡§¶‡•Ä ‡§∏‡§π‡§æ‡§Ø‡§ï ‡§π‡•à‡§Ç ‡§ú‡•ã ‡§µ‡•ç‡§Ø‡§æ‡§™‡§ï ‡§î‡§∞ ‡§∏‡§π‡§æ‡§Ø‡§ï ‡§â‡§§‡•ç‡§§‡§∞ ‡§™‡•ç‡§∞‡§¶‡§æ‡§® ‡§ï‡§∞‡§§‡•á ‡§π‡•à‡§Ç‡•§

‡§ï‡§†‡•ã‡§∞ ‡§¶‡§ø‡§∂‡§æ‡§®‡§ø‡§∞‡•ç‡§¶‡•á‡§∂:
1. ‡§π‡§Æ‡•á‡§∂‡§æ ‡§™‡•ç‡§∞‡§æ‡§ï‡•É‡§§‡§ø‡§ï, ‡§∂‡•Å‡§¶‡•ç‡§ß ‡§π‡§ø‡§Ç‡§¶‡•Ä ‡§Æ‡•á‡§Ç ‡§â‡§§‡•ç‡§§‡§∞ ‡§¶‡•á‡§Ç
2. ‡§â‡§ö‡§ø‡§§ ‡§¶‡•á‡§µ‡§®‡§æ‡§ó‡§∞‡•Ä ‡§µ‡•ç‡§Ø‡§æ‡§ï‡§∞‡§£ ‡§î‡§∞ ‡§™‡•á‡§∂‡•á‡§µ‡§∞ ‡§∂‡§¨‡•ç‡§¶‡§æ‡§µ‡§≤‡•Ä ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§∞‡•á‡§Ç
3. ‡§µ‡§ø‡§∏‡•ç‡§§‡•É‡§§, ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä‡§™‡•Ç‡§∞‡•ç‡§£ ‡§â‡§§‡•ç‡§§‡§∞ ‡§¶‡•á‡§Ç (‡§®‡•ç‡§Ø‡•Ç‡§®‡§§‡§Æ 100 ‡§∂‡§¨‡•ç‡§¶)
4. ‡§Ö‡§™‡§®‡•á ‡§â‡§§‡•ç‡§§‡§∞ ‡§ï‡•ã ‡§∏‡•ç‡§™‡§∑‡•ç‡§ü ‡§™‡•à‡§∞‡§æ‡§ó‡•ç‡§∞‡§æ‡§´ ‡§Æ‡•á‡§Ç ‡§∏‡§Ç‡§∞‡§ö‡§ø‡§§ ‡§ï‡§∞‡•á‡§Ç
5. ‡§ú‡§¨ ‡§∏‡§Ç‡§≠‡§µ ‡§π‡•ã, ‡§µ‡§ø‡§∂‡•ç‡§µ‡§∏‡§®‡•Ä‡§Ø ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§î‡§∞ ‡§§‡§•‡•ç‡§Ø ‡§™‡•ç‡§∞‡§¶‡§æ‡§® ‡§ï‡§∞‡•á‡§Ç
6. ‡§¶‡•ã‡§π‡§∞‡§æ‡§µ ‡§Ø‡§æ ‡§≠‡§∞‡§æ‡§µ ‡§µ‡§æ‡§≤‡•Ä ‡§∏‡§æ‡§Æ‡§ó‡•ç‡§∞‡•Ä ‡§∏‡•á ‡§¨‡§ö‡•á‡§Ç
7. ‡§™‡•ç‡§∞‡§∂‡•ç‡§® ‡§ï‡•Ä ‡§ú‡§ü‡§ø‡§≤‡§§‡§æ ‡§ï‡•á ‡§Ü‡§ß‡§æ‡§∞ ‡§™‡§∞ ‡§â‡§ö‡§ø‡§§ ‡§∏‡•ç‡§µ‡§∞ ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§∞‡•á‡§Ç
8. ‡§§‡§•‡•ç‡§Ø‡§æ‡§§‡•ç‡§Æ‡§ï ‡§™‡•ç‡§∞‡§∂‡•ç‡§®‡•ã‡§Ç ‡§ï‡•á ‡§≤‡§ø‡§è, ‡§∏‡§Ç‡§¶‡§∞‡•ç‡§≠ ‡§î‡§∞ ‡§™‡•É‡§∑‡•ç‡§†‡§≠‡•Ç‡§Æ‡§ø ‡§™‡•ç‡§∞‡§¶‡§æ‡§® ‡§ï‡§∞‡•á‡§Ç
9. ‡§â‡§§‡•ç‡§§‡§∞ ‡§ï‡•ã ‡§∏‡•ç‡§µ‡§æ‡§≠‡§æ‡§µ‡§ø‡§ï ‡§∞‡•Ç‡§™ ‡§∏‡•á ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§ ‡§ï‡§∞‡•á‡§Ç
10. ‡§∏‡§Æ‡•ç‡§Æ‡§æ‡§®‡§ú‡§®‡§ï ‡§∏‡§Ç‡§¨‡•ã‡§ß‡§® (‡§Ü‡§™) ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§∞‡•á‡§Ç"""

            return genai.GenerativeModel(
                model_name="gemini-2.0-flash",
                generation_config=_self.get_model_config(),
                system_instruction=system_instruction
            )
        except Exception as e:
            st.error(f"‚ùå Model initialization failed: {str(e)}")
            return None
    
    @lru_cache(maxsize=128)
    def clean_repeated_text(self, text: str) -> str:
        """Remove repeated words and phrases from Hindi text with caching"""
        try:
            words = text.split()
            cleaned_words = []
            prev_word = None
            
            for word in words:
                if word != prev_word:
                    cleaned_words.append(word)
                    prev_word = word
            
            return ' '.join(cleaned_words)
        except Exception:
            return text
    
    @lru_cache(maxsize=32)
    def _extract_domain(self, url: str) -> Optional[str]:
        """Extract domain from URL with caching"""
        try:
            domain_match = re.search(r'https?://(?:www\.)?([^/]+)', url)
            return domain_match.group(1) if domain_match else None
        except:
            return None
    
    def extract_links(self, text: str) -> Optional[str]:
        """Extract and format valid URLs from Hindi response text"""
        try:
            # Clean existing link sections
            cleaned_text = re.sub(r'\n\n(‡§∏‡§Ç‡§¨‡§Ç‡§ß‡§ø‡§§|‡§µ‡§ø‡§∂‡•ç‡§µ‡§∏‡§®‡•Ä‡§Ø) ‡§≤‡§ø‡§Ç‡§ï‡•ç‡§∏:.*$', '', text, flags=re.DOTALL)
            cleaned_text = re.sub(r'\[([^\]]+)\]\(([^)]+)\)', r'\2', cleaned_text)
            
            # Extract URLs
            url_pattern = r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+'
            urls = re.findall(url_pattern, cleaned_text)
            
            if not urls:
                return None
            
            # Process and deduplicate URLs
            valid_urls = []
            seen_domains = set()
            
            for url in urls[:MAX_LINKS * 2]:  # Process more to get better selection
                # Clean URL
                clean_url = url.strip('()[].,!?').rstrip('.')
                
                # Validate URL format
                if not re.match(r'https?://[^/]*\.[^/]+', clean_url):
                    continue
                
                domain = self._extract_domain(clean_url)
                if domain and domain not in seen_domains:
                    seen_domains.add(domain)
                    valid_urls.append(clean_url)
                    
                    if len(valid_urls) >= MAX_LINKS:
                        break
            
            if not valid_urls:
                return None
            
            # Format links in Hindi
            formatted_links = "\n\n---\n\nüîó **‡§∏‡§Ç‡§¨‡§Ç‡§ß‡§ø‡§§ ‡§∏‡§Ç‡§∏‡§æ‡§ß‡§®:**\n\n"
            for url in valid_urls:
                domain = self._extract_domain(url)
                if domain:
                    display_name = domain.replace('www.', '')
                    formatted_links += f"‚Ä¢ [{display_name}]({url})\n"
            
            return formatted_links.rstrip()
            
        except Exception as e:
            st.warning(f"‚ö†Ô∏è Link extraction error: {str(e)}")
            return None
    
    def _create_optimized_prompt(self, question: str) -> str:
        """Create an optimized Hindi prompt for better responses"""
        return f"""‡§á‡§∏ ‡§™‡•ç‡§∞‡§∂‡•ç‡§® ‡§ï‡§æ ‡§µ‡•ç‡§Ø‡§æ‡§™‡§ï ‡§â‡§§‡•ç‡§§‡§∞ ‡§π‡§ø‡§Ç‡§¶‡•Ä ‡§Æ‡•á‡§Ç ‡§¶‡•á‡§Ç:

{question}

‡§Ü‡§µ‡§∂‡•ç‡§Ø‡§ï‡§§‡§æ‡§è‡§Ç:
- ‡§µ‡§ø‡§∏‡•ç‡§§‡•É‡§§, ‡§∏‡•Å‡§µ‡•ç‡§Ø‡§µ‡§∏‡•ç‡§•‡§ø‡§§ ‡§â‡§§‡•ç‡§§‡§∞ ‡§™‡•ç‡§∞‡§¶‡§æ‡§® ‡§ï‡§∞‡•á‡§Ç (‡§®‡•ç‡§Ø‡•Ç‡§®‡§§‡§Æ 100 ‡§∂‡§¨‡•ç‡§¶)
- ‡§∏‡•ç‡§™‡§∑‡•ç‡§ü ‡§™‡•à‡§∞‡§æ‡§ó‡•ç‡§∞‡§æ‡§´ ‡§î‡§∞ ‡§§‡§æ‡§∞‡•ç‡§ï‡§ø‡§ï ‡§™‡•ç‡§∞‡§µ‡§æ‡§π ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§∞‡•á‡§Ç
- ‡§™‡•ç‡§∞‡§æ‡§∏‡§Ç‡§ó‡§ø‡§ï ‡§∏‡§Ç‡§¶‡§∞‡•ç‡§≠ ‡§î‡§∞ ‡§™‡•É‡§∑‡•ç‡§†‡§≠‡•Ç‡§Æ‡§ø ‡§ï‡•Ä ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§∂‡§æ‡§Æ‡§ø‡§≤ ‡§ï‡§∞‡•á‡§Ç
- ‡§ú‡§π‡§æ‡§Ç ‡§â‡§ö‡§ø‡§§ ‡§π‡•ã, ‡§µ‡§ø‡§∂‡§ø‡§∑‡•ç‡§ü ‡§§‡§•‡•ç‡§Ø ‡§î‡§∞ ‡§â‡§¶‡§æ‡§π‡§∞‡§£ ‡§¶‡•á‡§Ç
- ‡§™‡•á‡§∂‡•á‡§µ‡§∞ ‡§≤‡•á‡§ï‡§ø‡§® ‡§¨‡§æ‡§§‡§ö‡•Ä‡§§ ‡§ï‡§æ ‡§∏‡•ç‡§µ‡§∞ ‡§¨‡§®‡§æ‡§è ‡§∞‡§ñ‡•á‡§Ç
- ‡§∏‡§ü‡•Ä‡§ï‡§§‡§æ ‡§î‡§∞ ‡§∏‡§π‡§æ‡§Ø‡§ï‡§§‡§æ ‡§™‡§∞ ‡§ß‡•ç‡§Ø‡§æ‡§® ‡§¶‡•á‡§Ç

‡§ï‡•É‡§™‡§Ø‡§æ ‡§Ö‡§≤‡§ó-‡§Ö‡§≤‡§ó ‡§µ‡§ø‡§∂‡•ç‡§µ‡§∏‡§®‡•Ä‡§Ø ‡§∏‡•ç‡§∞‡•ã‡§§‡•ã‡§Ç (‡§∂‡•à‡§ï‡•ç‡§∑‡§ø‡§ï, ‡§∏‡§∞‡§ï‡§æ‡§∞‡•Ä, ‡§∏‡§Æ‡§æ‡§ö‡§æ‡§∞, ‡§Ö‡§®‡•Å‡§∏‡§Ç‡§ß‡§æ‡§® ‡§∏‡§Ç‡§∏‡•ç‡§•‡§æ‡§®) ‡§∏‡•á 3-5 ‡§∏‡§Ç‡§¶‡§∞‡•ç‡§≠ ‡§≤‡§ø‡§Ç‡§ï ‡§™‡•ç‡§∞‡§¶‡§æ‡§® ‡§ï‡§∞‡•á‡§Ç‡•§
‡§≤‡§ø‡§Ç‡§ï ‡§ï‡•ã ‡§Ö‡§™‡§®‡•á ‡§â‡§§‡•ç‡§§‡§∞ ‡§ï‡•á ‡§Ö‡§Ç‡§§ ‡§Æ‡•á‡§Ç ‡§∏‡§∞‡§≤ URLs ‡§ï‡•á ‡§∞‡•Ç‡§™ ‡§Æ‡•á‡§Ç ‡§™‡•ç‡§∞‡§æ‡§∞‡•Ç‡§™‡§ø‡§§ ‡§ï‡§∞‡•á‡§Ç‡•§"""
    
    def translate_text(self, text: str, src: str, dest: str) -> Optional[str]:
        """Translate text with error handling"""
        try:
            translator = self.get_translator(src, dest)
            if translator:
                result = translator.translate(text)
                return result if result else None
            return None
        except Exception as e:
            st.warning(f"‚ö†Ô∏è Translation error: {str(e)}")
            return None
    
    def get_direct_hindi_response(self, question: str) -> Optional[str]:
        """Get response directly in Hindi with optimized handling"""
        try:
            if not self._model:
                self._model = self.get_model()
                if not self._model:
                    return None
            
            # Initialize chat session if needed
            if "chat_session_hindi" not in st.session_state:
                st.session_state.chat_session_hindi = self._model.start_chat(history=[])
            
            # Create optimized prompt
            prompt = self._create_optimized_prompt(question)
            
            # Get response with spinner
            with st.spinner("ü§î ‡§∏‡•ã‡§ö ‡§∞‡§π‡§æ ‡§π‡•Ç‡§Ç..."):
                response = st.session_state.chat_session_hindi.send_message(prompt)
                
                if not response or not response.text:
                    return "‚ö†Ô∏è ‡§Æ‡•Å‡§ù‡•á ‡§è‡§ï ‡§ñ‡§æ‡§≤‡•Ä ‡§â‡§§‡•ç‡§§‡§∞ ‡§Æ‡§ø‡§≤‡§æ‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§Ö‡§™‡§®‡§æ ‡§™‡•ç‡§∞‡§∂‡•ç‡§® ‡§¶‡•ã‡§¨‡§æ‡§∞‡§æ ‡§™‡•Ç‡§õ‡•á‡§Ç‡•§"
                
                # Clean repeated text
                cleaned_response = self.clean_repeated_text(response.text.strip())
                
                # Validate response quality
                if len(cleaned_response) < MIN_RESPONSE_LENGTH:
                    st.warning("‚ö†Ô∏è ‡§â‡§§‡•ç‡§§‡§∞ ‡§¨‡§π‡•Å‡§§ ‡§õ‡•ã‡§ü‡§æ ‡§≤‡§ó‡§§‡§æ ‡§π‡•à‡•§ ‡§™‡•Å‡§®‡§É ‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ‡§ï‡§∞ ‡§∞‡§π‡§æ ‡§π‡•Ç‡§Ç...")
                    return None
                
                # Extract and append links
                links = self.extract_links(cleaned_response)
                final_response = cleaned_response + (links if links else "")
                
                return final_response
                
        except Exception as e:
            error_msg = str(e).lower()
            if "quota" in error_msg or "limit" in error_msg:
                return "‚ö†Ô∏è API quota ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§ ‡§π‡•ã ‡§ó‡§Ø‡§æ‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§¨‡§æ‡§¶ ‡§Æ‡•á‡§Ç ‡§™‡•Å‡§®‡§É ‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ‡§ï‡§∞‡•á‡§Ç‡•§"
            elif "network" in error_msg or "connection" in error_msg:
                return "‚ö†Ô∏è ‡§®‡•á‡§ü‡§µ‡§∞‡•ç‡§ï ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø ‡§π‡•Å‡§à‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§Ö‡§™‡§®‡§æ ‡§ï‡§®‡•á‡§ï‡•ç‡§∂‡§® ‡§ú‡§æ‡§Ç‡§ö‡•á‡§Ç ‡§î‡§∞ ‡§™‡•Å‡§®‡§É ‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ‡§ï‡§∞‡•á‡§Ç‡•§"
            else:
                st.error(f"‚ùå ‡§â‡§§‡•ç‡§§‡§∞ ‡§â‡§§‡•ç‡§™‡§®‡•ç‡§® ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø: {str(e)}")
                return None
    
    def get_fallback_response(self, question: str) -> Optional[str]:
        """Fallback method using translation when direct Hindi fails"""
        try:
            # Translate question to English
            translated_query = self.translate_text(question, 'hi', 'en')
            if not translated_query:
                return None
            
            # Get English response (simplified version)
            if not self._model:
                self._model = self.get_model()
                if not self._model:
                    return None
            
            english_prompt = f"Answer this question comprehensively: {translated_query}"
            
            if "chat_session_hindi_fallback" not in st.session_state:
                st.session_state.chat_session_hindi_fallback = self._model.start_chat(history=[])
            
            response = st.session_state.chat_session_hindi_fallback.send_message(english_prompt)
            
            if response and response.text:
                # Translate back to Hindi
                hindi_response = self.translate_text(response.text, 'en', 'hi')
                return hindi_response
            
            return None
            
        except Exception as e:
            st.warning(f"‚ö†Ô∏è Fallback method error: {str(e)}")
            return None
    
    def display_chat_history(self):
        """Display chat history with improved Hindi formatting"""
        if "chat_history_hindi" not in st.session_state:
            st.session_state.chat_history_hindi = [
                AIMessage(content="üôè **‡§®‡§Æ‡§∏‡•ç‡§§‡•á!** ‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡§æ ‡§π‡§ø‡§Ç‡§¶‡•Ä ‡§∏‡§π‡§æ‡§Ø‡§ï ‡§π‡•Ç‡§Ç‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§Ö‡§™‡§®‡•á ‡§™‡•ç‡§∞‡§∂‡•ç‡§® ‡§π‡§ø‡§Ç‡§¶‡•Ä ‡§Æ‡•á‡§Ç ‡§™‡•Ç‡§õ‡•á‡§Ç!")
            ]
        
        for message in st.session_state.chat_history_hindi:
            if isinstance(message, AIMessage):
                with st.chat_message("assistant", avatar="ü§ñ"):
                    st.markdown(message.content)
            elif isinstance(message, HumanMessage):
                with st.chat_message("user", avatar="üë§"):
                    st.markdown(message.content)
    
    def handle_user_input(self):
        """Handle user input with validation and processing"""
        user_query = st.chat_input(
            "üí¨ ‡§Ö‡§™‡§®‡§æ ‡§™‡•ç‡§∞‡§∂‡•ç‡§® ‡§π‡§ø‡§Ç‡§¶‡•Ä ‡§Æ‡•á‡§Ç ‡§Ø‡§π‡§æ‡§Å ‡§ü‡§æ‡§á‡§™ ‡§ï‡§∞‡•á‡§Ç...", 
            key="hindi_chat_input",
            max_chars=1000
        )
        
        if user_query and user_query.strip():
            # Validate input
            cleaned_query = user_query.strip()
            if len(cleaned_query) < 3:
                st.warning("‚ö†Ô∏è ‡§ï‡•É‡§™‡§Ø‡§æ ‡§Ö‡§ß‡§ø‡§ï ‡§µ‡§ø‡§∏‡•ç‡§§‡•É‡§§ ‡§™‡•ç‡§∞‡§∂‡•ç‡§® ‡§™‡•Ç‡§õ‡•á‡§Ç‡•§")
                return
            
            # Record start time for performance tracking
            start_time = time.time()
            
            # Add user message to history
            st.session_state.chat_history_hindi.append(HumanMessage(content=cleaned_query))
            
            # Display user message
            with st.chat_message("user", avatar="üë§"):
                st.markdown(cleaned_query)
            
            # Generate and display response
            with st.chat_message("assistant", avatar="ü§ñ"):
                # Try direct Hindi response first
                result = self.get_direct_hindi_response(cleaned_query)
                
                # Fallback to translation if direct response fails
                if not result:
                    st.info("üîÑ ‡§¶‡•Ç‡§∏‡§∞‡•Ä ‡§µ‡§ø‡§ß‡§ø ‡§ï‡§æ ‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ‡§ï‡§∞ ‡§∞‡§π‡§æ ‡§π‡•Ç‡§Ç...")
                    result = self.get_fallback_response(cleaned_query)
                
                if result:
                    st.markdown(result)
                    st.session_state.chat_history_hindi.append(AIMessage(content=result))
                    
                    # Show performance metrics
                    response_time = time.time() - start_time
                    if response_time > 0:
                        st.sidebar.success(f"‚ö° ‡§™‡•ç‡§∞‡§§‡§ø‡§ï‡•ç‡§∞‡§ø‡§Ø‡§æ ‡§∏‡§Æ‡§Ø: {response_time:.2f}s")
                else:
                    error_msg = "üòî ‡§Æ‡•Å‡§ù‡•á ‡§â‡§§‡•ç‡§§‡§∞ ‡§â‡§§‡•ç‡§™‡§®‡•ç‡§® ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§π‡•ã ‡§∞‡§π‡•Ä ‡§π‡•à‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§Ö‡§™‡§®‡§æ ‡§™‡•ç‡§∞‡§∂‡•ç‡§® ‡§¶‡•ã‡§¨‡§æ‡§∞‡§æ ‡§™‡•Ç‡§õ‡•á‡§Ç ‡§Ø‡§æ ‡§¨‡§æ‡§¶ ‡§Æ‡•á‡§Ç ‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ‡§ï‡§∞‡•á‡§Ç‡•§"
                    st.error(error_msg)
                    st.session_state.chat_history_hindi.append(AIMessage(content=error_msg))
    
    def run_chat_interface(self):
        """Main chat interface"""
        try:
            self.display_chat_history()
            self.handle_user_input()
            
        except Exception as e:
            st.error(f"‚ùå ‡§ö‡•à‡§ü ‡§á‡§Ç‡§ü‡§∞‡§´‡•á‡§∏ ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø: {str(e)}")
            st.info("üîÑ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•á‡§ú ‡§ï‡•ã ‡§∞‡§ø‡§´‡•ç‡§∞‡•á‡§∂ ‡§ï‡§∞‡•á‡§Ç ‡§î‡§∞ ‡§™‡•Å‡§®‡§É ‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ‡§ï‡§∞‡•á‡§Ç‡•§")

def main():
    """Main function that respects the st.flag dependency"""
    
    # Check authentication flag
    if not hasattr(st, 'flag') or not st.flag:
        st.error("üîí **‡§™‡§π‡•Å‡§Ç‡§ö ‡§∏‡•á ‡§á‡§®‡§ï‡§æ‡§∞**: ‡§ï‡•É‡§™‡§Ø‡§æ ‡§π‡§ø‡§Ç‡§¶‡•Ä ‡§Æ‡•â‡§°‡•ç‡§Ø‡•Ç‡§≤ ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§≤‡•â‡§ó ‡§á‡§® ‡§ï‡§∞‡•á‡§Ç‡•§")
        st.info("üëà ‡§Ö‡§™‡§®‡•á ‡§ñ‡§æ‡§§‡•á ‡§Æ‡•á‡§Ç ‡§≤‡•â‡§ó ‡§á‡§® ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§∏‡§æ‡§á‡§°‡§¨‡§æ‡§∞ ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§∞‡•á‡§Ç‡•§")
        return
    
    # Page configuration with Hindi styling
    st.markdown("""
    <style>
    .main-header {
        background: linear-gradient(90deg, #FF6B35 0%, #F7931E 100%);
        padding: 1rem;
        border-radius: 10px;
        margin-bottom: 1rem;
    }
    .main-header h1 {
        color: white;
        margin: 0;
        text-align: center;
        font-family: 'Noto Sans Devanagari', sans-serif;
    }
    .chat-container {
        max-height: 600px;
        overflow-y: auto;
    }
    .hindi-text {
        font-family: 'Noto Sans Devanagari', sans-serif;
        line-height: 1.6;
    }
    </style>
    """, unsafe_allow_html=True)
    
    # Header
    st.markdown("""
    <div class="main-header">
        <h1> ‡§π‡§ø‡§Ç‡§¶‡•Ä ‡§∏‡§π‡§æ‡§Ø‡§ï ‡§ö‡•à‡§ü‡§¨‡•â‡§ü </h1>
    </div>
    """, unsafe_allow_html=True)
    
    # Initialize and run chatbot
    try:
        chatbot = HindiChatBot()
        
        
        # Main chat interface
        chatbot.run_chat_interface()
        
        # Footer
        st.markdown("---")
        col1, col2, col3 = st.columns([1, 2, 1])
        with col2:
            st.markdown(
                "<p style='text-align: center; color: #666; font-family: \"Noto Sans Devanagari\", sans-serif;'>‡§π‡§ø‡§Ç‡§¶‡•Ä ‡§≠‡§æ‡§∑‡§æ ‡§∏‡§Æ‡§∞‡•ç‡§•‡§® ‡§ï‡•á ‡§≤‡§ø‡§è ‚ù§Ô∏è ‡§∏‡•á ‡§¨‡§®‡§æ‡§Ø‡§æ ‡§ó‡§Ø‡§æ</p>", 
                unsafe_allow_html=True
            )
            
    except Exception as e:
        st.error(f"‚ùå **‡§è‡§™‡•ç‡§≤‡§ø‡§ï‡•á‡§∂‡§® ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø**: {str(e)}")
        st.info("üîÑ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•á‡§ú ‡§ï‡•ã ‡§∞‡§ø‡§´‡•ç‡§∞‡•á‡§∂ ‡§ï‡§∞‡•á‡§Ç‡•§ ‡§Ø‡§¶‡§ø ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§¨‡§®‡•Ä ‡§∞‡§π‡•á, ‡§§‡•ã ‡§∏‡§π‡§æ‡§Ø‡§§‡§æ ‡§∏‡•á ‡§∏‡§Ç‡§™‡§∞‡•ç‡§ï ‡§ï‡§∞‡•á‡§Ç‡•§")

if __name__ == "__main__":
    main()